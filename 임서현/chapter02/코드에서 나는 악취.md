# 1. 기이한 이름

 

함수, 모듈, 변수, 클래스 등은 이름만 보고도 무슨 일을 하고 어떻게 사용해야하는지 명확히 알 수 있도록 이름을 지어야 한다.

<aside>

**사용하는 리팩터링**

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기
</aside>

# 2. 중복 코드



똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합해 더 나은 프로그램을 만들 수 있다.

<aside>

**사용하는 리팩터링**

- 함수 추출하기
- 문장 슬라이스하기
- 메서드 올리기
</aside>

- 문장 슬라이스 하기 : 완전히 똑같지 않은 경우 적용해 함수 추출하기를 쉽게 적용할 수 있는지 확인
- 메서드 올리기 : 같은 부모를 가진 자식 클래스들의 중복된 코드를 부모에게 옮긴다

# 3. 긴 함수

 

함수를 짧게 구성하면 코드 이해를 향상 시킬 수 있다.

주석을 달아야 할 부분은 무조건 함수로 만들고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.

<aside>

**사용하는 리팩터링**

- 함수 추출하기

**매개변수가 추출 작업에 방해되는 경우**

- 임시 변수를 질의 함수로 바꾸기
- 매개변수 객체 만들기
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기

**추출할 코드 찾아 내는 방법**

- 주석 참고
- 조건문, 반복문 참고
    - 조건문 분해하기
    - 조건문을 다형성으로 바꾸기
    - 반복문 쪼개기
</aside>

# 4. 긴 매개변수 목록

 

<aside>

**사용하는 리팩터링**

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 매개변수 객체 만들기
- 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기
</aside>

# 5. 전역 데이터

 

<aside>

**사용하는 리팩터링**

- 변수 캡슐화하기
</aside>

# 6. 가변 데이터

 

<aside>

**사용하는 리팩터링**

- 변수 캡슐화하기
- 변수 쪼개기
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
</aside>

- 변수 쪼개기 : 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우. 갱신 로직을 다른 코드와 떨어뜨리기 위해 **문장 슬라이스하기**, **함수 추출하기**를 사용

# 7. 뒤엉킨 변경

 

SRP가 지켜지지 않아 하나의 모듈이 다른 이유들로 인해 변경되는 일이 많을 때 발생하는 것이 뒤엉킨 변경이다.

<aside>

**사용하는 리팩터링**

- 단계 쪼개기
- 함수 옮기기
- 함수 추출하기
- 클래스 추출하기
</aside>

# 8. 산탄총 수술

 

뒤엉킨 변경이 한 코드에 여러 역할이 할당 된 경우 발생한다면 산탄총 수술은 한 역할이 여러 코드에 분산돼 있는 경우 발생한다.

<aside>

**사용하는 리팩터링**

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기
- 함수 인라인하기
- 클래스 인라인하기
</aside>

# 9. 기능 편애

 

한 함수가 다른 모듈의 함수나 데이터와 상호작용이 많은 경우 발생한다.

<aside>

**사용하는 리팩터링**

- 함수 옮기기 : 상호작용이 많은 데이터 근처로 이동
- 함수 추출하기 & 함수 옮기기 : 상호작용이 많은 일부 기능 추출 후 원하는 모듈로 옮긴다.
사용하는 모듈이 많은 경우 가장 많은 데이터를 포함한 모듈로 옮긴다.
</aside>

- 전략 패턴, 방문자 패턴, 자기 위임 함께 적용할 수 도 있다.

# 10. 데이터 뭉치

 

함께 뭉쳐 다니는 데이터 뭉치를 묶어준다.

<aside>

사용하는 리팩터링

- 클래스 추출하기
- 매개변수 객체 만들기
- 객체 통째로 넘기기
</aside>

값 하나를 삭제해 보면 데이터 뭉치인지 판별 할 수 있다.

# 11. 기본형 집착

 

`int`, `double`, `String` 같은 기본형(primitive)이나 단순 컬렉션만으로 모든 정보를 다루려는 습관

<aside>

**사용하는 리팩터링**

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- 매개변수 객체 만들기
</aside>

# 12. 반복되는 switch문

 

<aside>

**사용하는 리팩터링**

- 조건부 로직을 다형성으로 바꾸기

무조건적으로 바꿀 필요는 없고, 조건부 로직이 반복되는 경우 변경하는 쪽으로 한다.

</aside>

# 13. 반복분

 

<aside>

**사용하는 리팩터링**

- 반복문을 파이프라인으로 바꾸기
</aside>

# 14. 성의 없는 요소

 

이렇다할 역할이 없는 경우

<aside>

**사용하는 리팩터링**

- 함수 인라인하기
- 클래스 인라인하기
- 계층 합치기
</aside>

# 15. 추측성 일반화

 

미래를 대비해 작성한 코드가 있는경우

<aside>

**사용하는 리팩터링**

- 계층 합치기 : 하는 일이 없는 추상 클래스
- 함수 인라인하기
- 클래스 인라인하기
- 함수 선언 바꾸기
- 죽은 코드 제거하기
</aside>

# 16. 임시 필드

 

특정 상황에만 값이 설정되는 필드가 있는 경우

<aside>

**사용하는 리팩터링**

- 클래스 추출하기
- 함수 옮기기
- 특이 케이스 추가하기
</aside>

# 17. 메시지 체인

 

클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 객체 요청 작업이 연쇄적으로 이뤄지는 경우

<aside>

사용하는 리팩터링

- 위임 숨기기
- 함수 추출하기
- 함수 옮기기
</aside>

# 18. 중개자

 

중개자를 사용하는 대표적인 예로 캡슐화가 있다. 경우에 따라 위임이 많아지면 중개자 제거하기를 사용한다.

# 19. 내부자 거래

 

모듈간 공유되는 데이터가 많은 경우

<aside>

**사용하는 리팩터링**

- 함수 옮기기
- 필드 옮기기
- 위임 숨기기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기
</aside>

# 20. 거대한 클래스

 

한 클래스가 너무 많은 일을 하는 경우

<aside>

사용하는 리팩터링

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기
</aside>

# 21. 서로 다른 인터페이스의 대안 클래스들

 

클래스간 바뀔 대 같은 인터페이스를 사용해야한다.

<aside>

사용하는 리팩터링

- 함수 선언 바꾸기 : 메서드 시그니처를 일치 시킨다.
- 함수 옮기기 : 인터페이스가 같아 질 때 까지 필요한 동작들을 클래스에 넣는다.
- 슈퍼클래스 추출하기 : 클래스간 중복 코드가 생기는 경우 적용 고려한다.
</aside>

# 22. 데이터 클래스

 

필드와 getter/setter로만 구성된 클래스이다.

<aside>

사용하는 리팩터링

- 레코드 캐슐화하기
- setter 제거하기
- getter/setter을 사용하는 메서드를  찾앙 데이터 클래스로 함수 옮기기 혹은 함수 추출하기
</aside>

# 23. 상속 포기

 

<aside>

사용하는 리팩터링

- 메서드 내리기, 필드 내리기 : 상속 받지 않을 부모 코드를 전부 새로 만든 서브 클래스에 넘기고 공통 부분만 상속 받는다. (권장X)
- 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기를 활용하기
</aside>

# 24. 주석

 

1. 특정 코드에 주석을 남기고 싶다면 함수 추출하기를 적용한다.
2. 여전히 주석이 필요하면 함수 선언 바꾸기 적용한다.
3. 선행조건을 명시하고 싶다면 어서션 추가하기를 활용한다.

주석을 남겨야겠다는 생각이 든다면 주석이 필요없는 코드로 리팩터링해보자…
